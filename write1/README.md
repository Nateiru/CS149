# [Write Assignment 1](https://gfxcourses.stanford.edu/cs149/fall21content/static/pdfs/written_asst1.pdf)
[TOC]

## Problem 1: Superscalar and Hardware Multi-Threading

## Problem 2: Picking the Right CPU for the Job

[CMU 15-418/618: Exam 1 Practice Exercise SOLUTIONS](https://www.cs.cmu.edu/afs/cs/academic/class/15418-s18/www/exam1practice-solve.pdf)

### A
B > A > C
对于图像1，每一行的掩码是白色像素和黑色像素的混合：每个1个白色像素后面跟着3个黑色像素。由于CPU A和CPU B的SIMD宽度分别为32和2，这些处理器在执行这段ISPC代码时将受到分支分歧的影响。在处理黑色像素的ISPC程序实例将等待分配白色像素的gang实例完成它们的1000次循环迭代的执行。
- 处理器A 32-wide SIMD floating point 一次能计算32个float也就是图像的一行，但由于白色像素的影响，即便黑色只需要10周期也要等待白色像素1000次循环
- 处理器B 2-wide SIMD floating point 一次计算一行中的2个float单元，需要16次计算一行，其中一半会受到白色像素的影响需要等待
- 处理器C会逐个计算每行的float，需要32次计算完成

更细致的，每个处理器完成渲染一行需要多少个周期:
- A: 1000 cycles
- B: 8 × 1000 + 8 × 10  = 8080 cycles
- C: 10 × 24 + 1000 × 8 = 8240 cycles

然而，处理器C的频率为4 GHz，处理器B有12个核心(因此其吞吐量翻了一番)。因此,
每个平台的有效每行成本，标准化到1000 GHz单核处理器的周期，将是:
- A: 1000 ÷ 1000 = 1
- B: 8080 ÷ 1000 ÷ 12 = 0.67
- C: 8240 ÷ 1000 ÷ 4 = 2.06 
### B
在图像2中，与图像1不同，所有的行都是同质的。因此，处理器A和B不再受到分支分歧的影响。
- A: 1GHz × 32 = 32
- B: 1GHz × 12 × 2 = 24
- C: 4GHz × 1 = 4

由于所有处理器都以它们的峰值速率执行，拥有最强的原始处理能力的处理器将提供最佳的处理速度。A提供了最强大的原始处理能力，其次是B。

## Problem 3: A Task Queue on a Multi-Core, Multi-Threaded CPU
[CMU 15-418/618 Practice Exercise 1 SOLUTION](https://d1b10bmlvqabco.cloudfront.net/attach/i4gdt872i4o2f4/gxpjmy1uwr375q/i5dfnxkqllr1/exercise1soln.pdf)
### A
缓存大小是 32KB，但是每一轮访问的大小是 256KB，所有内存访问都是缓存失效。具体的比如在 `i` 是访问 `X[j]`，在 `i + 1`访问的时候 `X[j]` 的缓存已经失效。

现在，所有内存访问都是缓存失效，都需要承受 200 个周期的延迟。单线程的实现经过 200 个周期的内存停滞，然后进行 50 个周期的数学运算，接着再次经过 200 个周期的内存停滞，然后进行 50 个周期的数学运算，以此类推。因此，这导致了核心利用率为 20%。

而双线程配置可以将其中 50 个 200 周期的停滞与另一个线程的算术操作重叠，因此它实现了 40% 的利用率，运行速度加倍。两线程的配置将执行速度提高约 2 倍。


### B
在部分A中实现的 100% 利用率，需要支持五个交错硬件线程的处理器。

### C
- cache miss 的指令周期 200
- 算术操作的指令周期 100,000
按照上面的方式计算，由于算术操作计算复杂，计算密集型，cache miss 的指令周期影响不大，因此几乎不能提高速度。

### D

缓存大小是 1MB，但是每一轮访问的大小是 256KB，两个线程总的数据量是 512KB。在这种情况下，使用一个线程和两个线程的配置之间的性能差异不大，因为它们都会接近100% 地利用处理器，因此运行速度大致相同。这是因为在这种情况下几乎没有缓存失效，因为几乎所有的内存访问都由缓存提供服务。因此，没有需要隐藏的延迟，因此在这种情况下没有硬件多线程的好处。
### E
一个线程，理由如下：
现在，当运行一个线程时，线程的工作集适合缓存。这个线程基本上没有缓存丢失，并且以100% 的利用率运行。双线程配置需要 512KB的缓存 (但缓存只有 384KB)，因此，就像在 A 部分一样，所有的内存访问都是缓存丢失。我们从 A 部分指出，两个线程的配置将实现 40% 的核心利用率，因此一个线程配置的速度是原来的 2.5 倍。